#Search先简单看看

###Linear Search


故意，人家就是故意用vector来写的，哼唧~

但是没有template generric programming


```
int linearSearch(const vector<int> &a, int val){
    
    for (vector<int> :: size_type ix = 0; ix != a.size(); ix++) {
        if (a[ix] == val) {
            return ix;
        }
    }
    return -1;

}

```

###Binary Search

binary search的前提是要sorted

do so in C++
说实话，我都不知道C++ algorithm库里面的这个sort是啥sort方法：

```
#include <algorithm>

using namespace std;

sort(v1.begin(),v1.end());
```


递归版本，binarySearch本身就很递归



```

int binarySearchWrapper(const vector<int> &a, int val, int left, int right){
    if (left <= right) {
        int mid = (left + right)/2;
        if (val  < a[mid]) return binarySearchWrapper(a, val, left, mid-1);
        else if (val > a[mid]) return binarySearchWrapper(a, val, mid + 1, right);
        else return mid;
    }
    return -1;
}


int binarySearch(const vector<int> &a, int val){
    return binarySearchWrapper(a, val, 0, a.size()-1);
}

```

非递归版本反而是对我来说还要think twice


```
int binarySearch(const vector<int> &a, int val)
{
  int left = 0, right = a.size() - 1;
  while(left <= right){
    int mid = (left + right) / 2;
    if (val < a[mid]){
      right = mid - 1;
    } else if (val > a[mid]){
      left = mid + 1;
    } else
      return mid;
  }
  return -1;
}


```



###LinkedList即使是sorted搜索效率也是O(N)

LinkedList 就只能linear search来扫节点，所以效率是逃不出O(N)的....



