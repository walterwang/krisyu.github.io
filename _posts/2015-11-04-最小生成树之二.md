#最小生成树之二

###定义
Spanning tree of a weighted graph with minimum total edge weight一般仅考虑undirected...
Applications：
 - Communications networks - Transportation networks
 
 
###Kruskal Algorithm

 伪码如下：
超级好记

If the graph can make a minimum spanning tree, the steps would be as follows:

```
sort the edges in a queue
	while not all vertices are included: 
		pick the smallest one, delete it from the queue 
		if no cycle:
			add that one to make MST
		else:
			ignore it
```

两句话可以讲清楚的：1. Sort edges by increasing edge weight2. Select the first |V| – 1 edges that do not generate a cycle时间复杂度分析：

- heap来排edge
- O(mn)用来跳m个edge同时检查cycleO(mlogm) + O(nm) = O(n<sup>2</sup>logn<sup>2</sup>) + O(n<sup>3</sup>) = O(n<sup>3</sup>)
sparse graph should use，因为切入点是边
###Prim Algorithm
```
MST-Prim(G, w, r)    Q = V[G];    for each u  Q        key[u] = ∞ ;    key[r] = 0;    p[r] = NULL;    while (Q not empty)        u = ExtractMin(Q);        for each v ∈ Adj[u]            if (v ∈ Q and w(u,v) < key[v])                p[v] = u;                key[v] = w(u,v);```
Prim 非常 类似Dijkstra算法，除了所谓的relax edge不同而已,见此：
[Prim vs Dijkstra][id]
[id]:http://stackoverflow.com/questions/14144279/difference-between-prims-and-dijkstras-algorithm时间复杂度分析:
- O(1) init all vertex
- O(n) 挑 edges
- O(m) 挑 edgesO(1) + O(n(m+1)) = O(nm) = O(n<sup>3</sup>) in the worst casedense graph should choose