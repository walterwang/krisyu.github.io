#Dijkstra算法

###前提


前提是(Dijkstra):

- the graph is connected 
- the edge weights are nonnegative


###Dijkstra算法

wikipedia上的伪码

这个算法不算难理解，看伪码：

关键点类似Prim算法，可以想象有一个cloud，一个一个收入vertex，然后每次收入distance最短的那个，同时更新更种distance，如果新收入的会引起更小的distance的话，继续更...


```
function Dijkstra(Graph, source):

	dist[source] = 0
		
	create vertex set Q 
	
	for each vertex v in Graph:
		if v != source:
			dist[v] = INFINITY
			//prev[v] = UNDEFINED 这是用来记录路径的
		Q.add_with_priority(v,dist[v])
	
	while !Q.empty():
		u = Q.extract_min()
		for each neighbor v of u:
			alt = dist[u] + weight(u,v)
			if alt < dist[v]
				dist[v] = alt
				prev[v] = u
				Q.decrease_priority(v,alt)
				
	return dist[],prev[]

```

这个算法可以有很多“改写“版本。

用C++来实现可占便宜的地方有，利用STL来做min_priority_queue,在[Heap君之二][id]有有写到利用函数重载来完成。

//然而发现其实并没有占到什么便宜，因为这个伪码之中有出现decrease_priority这种method，STL中提供的priority_queue并没有这样的很方便可以implement的方法。写到一半开始泪目|||

[id]:http://krisyu.github.io/2015/heap君之二/


时间复杂度 O((n + m) log n) 

出现logn是因为heap排序啥的

然后也很容易理解negative cycle会导致Dijkstra算法不可用，因为如果有negative cycle那么就可以一直绕一直减小...


####另一处的伪码

在被graph theory及其implement搞晕之前，我去图书馆随手找了一本书。
然后发现其实别人也没有特别要躲开pointer.

首先matrix不用多说。
然后adjacency lists是这样：

```
class Graph
{
private:
	List<int> * headNodes;
	int n;
public:
	Graph(const int vertices = 0) :n(vertices)
	{
		headNodes = new List<int>[n];
	};
};

```

然后给的dijkstra算法是用adjacency matrix来处理：


```
class Graph
{	
private:
	int length[nmax][nmax];
	int dist[nmax];
	Boolean s[nmax];
public:
	void ShortestPath(const int, const int);
	int choose(const int);
};

```

算法类似这样：

```
void Graph::ShortestPath(const int n, const int v)
{
	for(int i = 0; i < n ; i++)
	{
		s[i] = false;
		dist[i] = length[v][i];
	} //initialize
	
	s[v] = true;
	dist[v] = 0;
	
	for(int i= 0; i < n ; i++){ 
		// determine n-1 paths from vertex v
		//int u = choose(n);//choose returns a value u such that :
		// dist[u] = minimum dist[w], where s[w] = FALSE
							
		int u ;
		int min = UNREACH;
		for (int j = 0; j < N; ++j)
		{
			if (!s[j] && dist[j] <= min)
			{
				u = j;
				min = dist[j];
			}
		}				  
		
		s[u] = TRUE;
		for(int w = 0; w < n ; w++){
			if(!s[w])
				if(dist[u] + length[u][w] < dist[w])
					dist[w] = dist[u] + length[u][w];
		}
	}
}

```

然后choose可以这样来直接写到函数里面，就像这样。





这个的好处是避开了decrease_priority，避开了写minHeap，但是我今天试着用这个伪码来做一道题...妈呀出错|||

我改改改，看别人的讨论，看别人的代码，终于对鸟....

[题在此][id2]

[id2]:https://github.com/KrisYu/HackerRank/blob/master/dijkstrashortreach.cpp











