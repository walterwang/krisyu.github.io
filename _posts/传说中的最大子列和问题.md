#传说中的最大子列和问题




###算法1 ： 穷举/暴力 

优点是容易理解，容易想到，缺点是耗时长

```

int maxSubSum1( const vector<int> & a )    int maxSum = 0;    for( int i = 0; i < a.size( ); ++i )        for( int j = i; j < a.size( ); ++j )        {            int thisSum = 0;            for( int k = i; k <= j; ++k )                thisSum += a[ k ];            if( thisSum > maxSum )                maxSum = thisSum;}    return maxSum;}
```

容易理解，从vector中取段来相加，然后最后求得maxSum,缺点是复杂度为cubic.




###算法二

```

int maxSubSum2( const vector<int> & a)
{
  int maxSum = 0;
  
  for(int i = 0; i < a.size() ; ++i)
  {
    int thisSum = 0;
    for(int j = i; j < a.size(); ++j)
    {
      thisSum += a[j];
      
      if(thisSum > maxSum)
        maxSum = thisSum;
    }
  }
  
  return maxSum;
}
```

i是子列的左端
j是子列的右端


###算法三

```


```

