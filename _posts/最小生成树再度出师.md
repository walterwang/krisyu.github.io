#最小生成树再度出师

### Prim算法

之前写过Prim算法和Kruskal算法的伪码，在一篇文章内，然后我用来刷题了，悲剧啊！惨剧！！！！！

看我的[core code][id1]，我这是从一个Dijkstra改过来的

[id1]:https://github.com/KrisYu/HackerRank/blob/master/primsmstsub.cpp

然后我又再次来尝试理解Prim算法，是这样的


![Graph](images/graph.png =300x)


- Initialize a tree with a single vertex, chosen arbitrarily from the graph.
- Grow the tree by one edge: of the edges that connect the tree to vertices not yet in the tree, find the minimum-weight edge, and transfer it to the tree.
- Repeat step 2 (until all vertices are in the tree).

实际上来看，假设起点是1
- MST= {1}， 然后更新到【2】距离为3，到【3】距离为4
- 从1出去的edge，挑选【2】，MST = {1，2}，同时更新距离【4】 为6，【5】为2
- 选中【5】，MST= {1，2，5}，到3的距离不更新

树组完：

```
				 1 
				| \
				|   2 - 4
				|    \
				3     5
```
所以总的weigh是 3 + 4 + 2 + 6 = 15


因为Prim是把所有的点最终都收入，所以关键的是要记录一个点的parent/previous，所以再来看一个伪码,然后虽然与Dijkstra类似，但是每次relax的edge的方式是不一样的,[见此][id]:

[id]:http://stackoverflow.com/questions/14144279/difference-between-prims-and-dijkstras-algorithm
```
MST-PRIM (G, w, r) {

        for each key ∈ G.V

            u.key = ∞
            u.parent = NIL

        r.key = 0
        Q = G.V
        while (Q ≠ ø)

            u = Extract-Min(Q)
            for each v ∈ G.Adj[u]

                if (v ∈ Q) and w(u,v) < v.key

                    v.parent = u
                    v.key = w(u,v)    <== relax function, Pay attention here

}

```

###Kruskal 算法

好吧，虽然伪码真的很简单，但是我写不出来，算法...并查集//待研究


###Transitive Closure


