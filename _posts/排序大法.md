#排序大法之一

###简单排序

稳定性： 两个相等的数据排序前后相对位置不变


###冒泡排序

原理： 两两比较，大的下移，小的上浮，like 冒泡
第一趟： N-1 → N排好
第二趟： N-2 → N-1排好
 ...
 
 
所以需要两重循环
一个用于控制第二个循环的终点
另加flag之后可以用于判断，如果走一圈完全没有交换则说明排序已经完成

```

void swap(int &a, int &b){
	int temp = a;
	a = b;
	b = temp ;
}

void bubble_sort(int a[],int n)
{
	int p,flag,i;
	for (p = n-1 ; p >= 0 ; p--){
		flag = 0;
		for (i = 0; i < p; i++){
			if (a[i] > a[i+1])
			{
				swap(&a[i],&a[i+1]);
				flag = 1;
			}
		}
		if (flag == 0)
			break;
	}
}
```

###插入排序

拿扑克
拿到的扑克与手上的比，如果比最后一张大，则直接放于此张之后
如果比最后一张小，那么就需要继续向前比，知道遇到比其小的，那么放于此张之后

```

void insertion_sort(int a[],int n)
{
    int p,tmp,i;
	for ( p = 1; p < n; p++){
		tmp = a[p];
		for (i = p; i > 0 && a[i-1] > tmp; i--)
			a[i] = a[i-1];
		a[i] = tmp;
	}
}

```

逆序对
交换2个相邻元素正好消去1个逆序对
对于插入排序：
T(N,I) = O(N+I)
所以如果序列基本有序，插入排序简单&高效

有定理：
任意N个不同元素组成的序列平均具有 N(N-1)/4个逆序对

所以这种交换逆序对的方式逃不开平均时间复杂度N^2
（这也是之后的排序为什么能摆脱N^2的原因）

简单排序完毕

----------
###希尔排序

```
void shell_sort(int a[],int n){
    int d,p,tmp,i;
    for (d = n/2; d>0; d/=2) {
        for ( p = d; p < n; p++) {
            tmp = a[p];
            for (i = p; i>=d && a[i-d]>tmp; i -= d)
                a[i] = a[i-d];
            a[i] = tmp;
        }
    }
}

```
增量序列的选取可能极大的影响算法效率

所以有：
Hibbard增量序列
Sedgewick增量序列

###堆排序

算法一：

```
void heap_sort(elementtype a[],int n)
{
	buildheap(a);
	for ( i = 0; i < n; i++)
		tmpa[i] = deletemin(a);
	for (i = 0; i < n; i++)
		a[i]= tmpa[i]
}

```

但是需要额外O（N）空间，并且复制亦要花时间

算法二：

```
void percdown(int a[] , int i, int n) {
    int child,tmp;
    for (tmp = a[i]; 2*i + 1 < n; i = child) {
        child = 2*i + 1;
        if (child < n - 1 && a[child] < a[child + 1])
            child++;
        if (tmp < a[child])
            a[i] = a[child];
        else
            break; 
    } 
    a[i] = tmp; 
}

void heap_sort(int a[],int n){
    for (int i = n/2; i >= 0; i--)
        percdown(a, i, n);
    for (int i = n - 1 ; i > 0 ; i--) {
        swap(&a[0], &a[i]);
        percdown(a, 0, i);
    }
}

```
我个人觉得理解这个算法关键有：

- 现在对于一个父结点，其子结点为` 2*i+1 和  2*i+2`
- percdown函数的作用的理解： 
   - i是待调整数组元素的位置，n是数组的长度
   -  之所以一开始要有从n/2开始调整到0是因为一开始调整为最大堆是需要调整所有的父结点
   - 交换之后就只需要调整0到i的部分了

###归并排序
递归算法

```
void merge(int a[],int tmpa[],int l, int r, int rightend){
    int leftend,tmp,numelements;
    leftend = r - 1;
    tmp = l;
    numelements = rightend - l + 1;
    while (l <= leftend && r <= rightend ) {
        if(a[l] <= a[r]) tmpa[tmp++] = a[l++];
        else             tmpa[tmp++] = a[r++];
    }
    while (l <= leftend)
        tmpa[tmp++] = a[l++];
    while (r <= rightend)
        tmpa[tmp++] = a[r++];
    for (int i = 0 ; i < numelements; i++, rightend--)
        a[rightend] = tmpa[rightend];
}

void msort(int a[],int tmpa[],int l, int rightend)
{
    int center;
    if ( l < rightend ) {
        center = (l + rightend)/2;
        msort(a,tmpa,l,center);
        msort(a,tmpa,center+1,rightend);
        merge(a, tmpa, l, center+1, rightend);
    }
}

void merge_sort(int a[],int n)
{
    int *tmpa;
    tmpa = malloc(n * sizeof(int));
    if ( tmpa != NULL ) {
        msort(a, tmpa, 0, n-1);
        free(tmpa);
    }
    else
        printf("no enough space to sort.");
}


```

非递归算法
注意这里的merge1 是之前的merge的变体，但是不要将tmpa 再返回a中

```
void merge_pass(int a[],int tmpa[],int n, int length)
{
    int i;
    for ( i = 0; i <= n - 2*length ; i += 2*length)
        merge1(a, tmpa, i, i+length, i + 2*length-1);
    if ( i+ length < n)
        merge1(a, tmpa, i, i+length, n-1);
    else
        for (int j = i; j < n; j++) tmpa[j] = a[j];
}
void merge_sort(int a[],int n)
{
    int *tmpa;
    tmpa = malloc(n * sizeof(int));
    int length = 1;
    if ( tmpa != NULL ) {
        while (length < n) {
            merge_pass(a, tmpa, n, length);
            length *= 2;
            merge_pass(tmpa, a, n, length);
            length *= 2;
        }
        free(tmpa);
    }
    else
        printf("no enough space to sort.");
}


```


###ZZZ###

如有错误，请多指教。



<a href="http://twitter.com/yuxue1989">Twitter</a>

<a href="mailto:xue_yu@me.com?subject=Hello">Email</a>



