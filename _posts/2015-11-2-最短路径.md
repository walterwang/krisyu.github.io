#最短路径



###Unweighted Graph

这个其实跟BFS类似很容易想到，因为其实是一个数层数的问题，距离S第几层.
因为BFS也是从进入点一层一层往外search的，所以不难想到。

```
void unweighted(vertex s)
{
	enqueue(s,q);
	while(!isempty(q)){
		v = dequeue(q);
		for(v 的每个邻接点 w){
			if(dist[w] == -1){
				dist[w] = dist[v] + 1;
				path[w] = v;
				enqueue(W,q);
			}
		}
	}
}
```

dist[w] = s到w的最短距离

dist[s] = 0

path[w] = s到w的路上经过的某顶点






###Dijkstra算法

####wikipedia上的伪码

这个算法不算难理解，看伪码：


```
function Dijkstra(Graph, source):

	dist[source] = 0
		
	create vertex set Q 
	
	for each vertex v in Graph:
		if v != source:
			dist[v] = INFINITY
			//prev[v] = UNDEFINED 这是用力记录路径的
		
		Q.add_with_priority(v,dist[v])
	
	while !Q.empty():
		u = Q.extract_min()
		for each neighbor v of u:
			alt = dist[u] + weight(u,v)
			if alt < dist[v]
				dist[v] = alt
				//prev[v] = u
				Q.decrease_priority(v,alt)
				
	return dist[]//,prev[]

```

这个算法可以有很多“改写“版本。

用C++来实现可占便宜的地方有，利用STL来做min_priority_queue,在[Heap君之二][id]有有写到利用函数重载来完成。

//然而发现其实并没有占到什么便宜，因为这个伪码之中有出现decrease_priority这种method，STL中提供的priority_queue并没有这样的很方便可以implement的方法。写到一半开始泪目|||

[id]:http://krisyu.github.io/2015/heap君之二/

####另一处的伪码

在被graph theory及其implement搞晕之前，我去图书馆随手找了一本书。
然后发现其实别人也没有特别要躲开pointer.

首先matrix不用多说。
然后adjacency lists是这样：

```
class Graph
{
private:
	List<int> * headNodes;
	int n;
public:
	Graph(const int vertices = 0) :n(vertices)
	{
		headNodes = new List<int>[n];
	};
};

```

然后给的dijkstra算法是用adjacency matrix来处理：


```
class Graph
{	
private:
	int length[nmax][nmax];
	int dist[nmax];
	Boolean s[nmax];
public:
	void ShortestPath(const int, const int);
	int choose(const int);
};

```

算法类似这样：

```
void Graph::ShortestPath(const int n, const int v)
{
	for(int i = 0; i < n ; i++){s[i] = false; dist[i] = length[v][i];} //initialize
	s[v] = true;
	dist[v] = 0;
	
	for(int i= 0; i < n ; i++){ // determine n-1 paths from vertex v
		//int u = choose(n);//choose returns a value u such that :
							// dist[u] = minimum dist[w], where s[w] = FALSE
		//					
		int u ;
		int min = UNREACH;
		for (int j = 0; j < N; ++j)
		{
			if (!s[j] && dist[j] <= min)
			{
				u = j;
				min = dist[j];
			}
		}				  
		
		s[u] = TRUE;
		for(int w = 0; w < n ; w++){
			if(!s[w])
				if(dist[u] + length[u][w] < dist[w])
					dist[w] = dist[u] + length[u][w];
		}
	}
}

```

然后choose可以这样来直接写到函数里面，比较方便。





这个的好处是避开了decrease_priority，避开了写minHeap，但是我今天试着用这个伪码来做一道题...妈呀出错|||

我改改改，看别人的讨论，看别人的代码，终于对鸟....

###Bellman–Ford algorithm

摘自wikipedia


```
function BellmanFord(list vertices, list edges, vertex source)
   ::distance[],predecessor[]

   // This implementation takes in a graph, represented as
   // lists of vertices and edges, and fills two arrays
   // (distance and predecessor) with shortest-path
   // (less cost/distance/metric) information

   // Step 1: initialize graph
   for each vertex v in vertices:
       if v is source then distance[v] := 0
       else distance[v] := inf
       predecessor[v] := null

   // Step 2: relax edges repeatedly
   for i from 1 to size(vertices)-1:
       for each edge (u, v) with weight w in edges:
           if distance[u] + w < distance[v]:
               distance[v] := distance[u] + w
               predecessor[v] := u

   // Step 3: check for negative-weight cycles
   for each edge (u, v) with weight w in edges:
       if distance[u] + w < distance[v]:
           error "Graph contains a negative-weight cycle"
   return distance[], predecessor[]

```
