#Dijkstra 算法


###wikipedia上的伪码

这个算法不算难理解，看伪码：


```
function Dijkstra(Graph, source):

	dist[source] = 0
		
	create vertex set Q 
	
	for each vertex v in Graph:
		if v != source:
			dist[v] = INFINITY
			//prev[v] = UNDEFINED 这是用力记录路径的
		
		Q.add_with_priority(v,dist[v])
	
	while !Q.empty():
		u = Q.extract_min()
		for each neighbor v of u:
			alt = dist[u] + weight(u,v)
			if alt < dist[v]
				dist[v] = alt
				//prev[v] = u
				Q.decrease_priority(v,alt)
				
	return dist[]//,prev[]

```

这个算法可以有很多“改写“版本。

用C++来实现可占便宜的地方有，利用STL来做min_priority_queue,在[Heap君之二][id]有有写到利用函数重载来完成。

//然而发现其实并没有占到什么便宜，因为这个伪码之中有出现decrease_priority这种method，STL中提供的priority_queue并没有这样的很方便可以implement的方法。写到一半开始泪目|||

[id]:http://krisyu.github.io/2015/heap君之二/

###另一处的伪码

在被graph theory及其implement搞晕之前，我去图书馆随手找了一本书。
然后发现其实别人也没有特别要躲开pointer.

首先matrix不用多说。
然后adjacency lists是这样：

```
class Graph
{
private:
	List<int> * headNodes;
	int n;
public:
	Graph(const int vertices = 0) :n(vertices)
	{
		headNodes = new List<int>[n];
	};
};

```

然后给的dijkstra算法是用adjacency matrix来处理：


```
class Graph
{	
private:
	int length[nmax][nmax];
	int dist[nmax];
	Boolean s[nmax];
public:
	void ShortestPath(const int, const int);
	int choose(const int);
};

```

算法类似这样：

```
void Graph::ShortestPath(const int n, const int v)
{
	for(int i = 0; i < n ; i++){s[i] = false; dist[i] = length[v][i];} //initialize
	s[v] = true;
	dist[v] = 0;
	
	for(int i= 0; i < n ; i++){ // determine n-1 paths from vertex v
		int u = choose(n);//choose returns a value u such that :
						  // dist[u] = minimum dist[w], where s[w] = FALSE
		
		s[u] = TRUE;
		for(int w = 0; w < n ; w++){
			if(!s[w])
				if(dist[u] + length[u][w] < dist[w])
					dist[w] = dist[u] + length[u][w];
		}
	}
}

```

这个的好处是避开了decrease_priority，避开了写minHeap，但是我今天试着用这个伪码来做一道题...妈呀出错|||

//然后发现if a node is unreachable, the distance is assigned as -1, 原来是这里出错了，也许它给了-1？ 总之这里待改



