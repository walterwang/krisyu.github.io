#最小生成树

###Kruskal算法-将森林合并成树

伪码如下

不难理解，难以实现， 最小堆， 并查集，表示自己已经头大。

```
void Kruskal(Graph G){
	MST = {};
	while ( MST中不到 |V| - 1 条边 && E中还有边){
		从E中选取一条权重最小的边E<V,W>; /* 最小堆 */
		将 E<V,W>从E众删除；
		if (E<V,W>不在MST中构成回路) /* 并查集 */
			将 E(V,W)加入MST;
		else
			彻底无视 E(V,W); 
	}
	if (MST 中不到 |V| - 1条边)
		Error("生成树不存在");
}

```
Kruskal的入口是边，所以如果是稀疏图的话，那么就会划算。



###Prim算法-让一颗小树长大


好像Dijkstra算法，所以我也写个不用priority queue的伪码吧，因为这个MST是从顶点入手，所以如果是稠密图才划算。

同样来写一个不用priority queue的伪码吧：

还有的问题是因为收入的都是顶点，如果想要知道它们是如何连起来的话，需要一个所谓的parent或者previous做记录。

```
void Prim()
{
	MST = {s};
	while(1){
		V = 未收录定点中dist最小者；
		if（这样的V不存在）
			break；
		将V收录进MST : dist[V] = 0;
		for( V的每个邻接点 W)
			if(dist[W]!= 0)
				if(E(V,W) < dist[W]){
					dist[W] = E(V,W);
					parent[W] = V;
				}
	}
	if(MST中收的顶点不到|V|个)
		Error("生成树不存在");
}
```


