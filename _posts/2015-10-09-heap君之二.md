#Heap君之二

### MaxHeap as Priority Queue



大概还是处于出神状态吧，之前一直在想要如何用 vector 来 implement maxheap，居然错过了如此重要的一句话：

```
A priority queue can be implemented as a heap```
还有的原因就是STL还没到我的血液中去,知道STL里面有queue，vector，stack，priority queue，好像要更把他们放心上。

[这一篇][id]写的很好，STL大法好：


[id]: http://www.technical-recipes.com/2011/priority-queues-and-min-priority-queues-in-c/ "Priority Queues and Min Priority Queues in STL / C++"


这就是MaxHeap的样子啊：

####MaxHeap


```
#include <iostream>  
#include <queue>  
using namespace std;  
  
int main()  
{  
    priority_queue<int> pq;  
  
    pq.push(3);  
    pq.push(5);  
    pq.push(1);  
    pq.push(8);  
    while ( !pq.empty() )  
    {  
        cout << pq.top() << endl;  
        pq.pop();  
    }  
    cin.get();  
}  
```

####MinHeap

还有方便的MinHeap，利用STL和运算符重载


```
#include <iostream>  
#include <queue>  
using namespace std;  
  
struct compare  
{  
  bool operator()(const int& l, const int& r)  
  {  
      return l > r;  
  }  
};  
  
int main()  
{  
    priority_queue<int,vector<int>, compare > pq;  
  
    pq.push(3);  
    pq.push(5);  
    pq.push(1);  
    pq.push(8);  
    while ( !pq.empty() )  
    {  
        cout << pq.top() << endl;  
        pq.pop();  
    }  
    cin.get();  
}  

```

###用Vector来写一个

bonus at here [file][id]

[id]:https://github.com/KrisYu/DataStructure/tree/master/MinHeap

基本原理在上一篇已经写过，不过写的时候还是有很多小细节:
比如可选到底从 v[0]开始放东西还是 v[1],然后值得注意的还有：


``` 
-1/2 = 0 

```

然后C++里面是直接提供了swap函数，比如要交换v[0] 和 v[n] 可以直接用


```
 swap(v[0],v[1])
```

值得注意的是，insert和delete当然可以用while loop（iteration）或者可以用 recursion来做，recursion看起来好像更优雅，也算直观很容易想到。

比如插入这个操作，借助percUp：

####percUp


插入之后比较，然后上浮到合适的位置



```
void percUp(int idx){
    int prt = parent(idx);
    if(idx >= 0 && prt >=0 && v[prt] > v[idx] ){
        swap(v[prt],v[idx]);
        percUp(prt);
    }
}

```

####percDown

下沉稍复杂于上浮，因为需要和左右孩子比较，注意的点是：把smallIdx初始化为idx，这样如果不需要下沉就直接return

```

void percDown(int idx){
    int l = left(idx);
    int r = right(idx);
    //init smallIdx for the return case
    int smallIdx = idx;
    
    if( l != -1 && v[idx] > v[l] )
        smallIdx = l;
    if( r != -1 && v[smallIdx] > v[r])
        smallIdx = r;
    
    if(smallIdx == idx)
        return;
    else{
        swap(v[idx],v[smallIdx]);
        percDown(smallIdx);
    }
}
```

如果有出错之处恳求指出