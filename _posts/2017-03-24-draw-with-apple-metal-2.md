---
layout: post
title: "用Apple Metal画东西2"
---

# 用Apple Metal画东西2


### 清理Code

把render function包含：

1. 创建 device
2. 创建 commandQueue
3. createBuffer()
4. registerShaders()


#### createBuffer

创建buffer并且放到vertexBuffer中， 此次我们想要Vertex包含更多东西，所以定义一个struct 来包含需要的位置和颜色

```
struct Vertex {
    var position: vector_float4
    var color: vector_float4
}
```


原本的 

- 创建 vertexData
- 把vertexData传入 vertexBuffer （知道vertexData大小，然后用device.makeBuffer传入

被简化为：

```
func createBuffer() {
    let vertex_data = [Vertex(position: [-1.0, -1.0, 0.0, 1.0], color: [1, 0, 0, 1]),
                       Vertex(position: [ 1.0, -1.0, 0.0, 1.0], color: [0, 1, 0, 1]),
                       Vertex(position: [ 0.0,  1.0, 0.0, 1.0], color: [0, 0, 1, 1])]
    vertex_buffer = device!.newBufferWithBytes(vertex_data, length: sizeof(Vertex) * 3, options:[])
}
```

#### register shader

步骤基本不变

- 创建library
- 创建 vertex\_func 和 frag\_func （用library.makeFunction
- 创建 rpld MTLRenderPipelineDescriptor()
- 把这个rpld的vertexFunc 和 fragmentFunction 设置为刚定义的的vertex\_func 和 frag_func
- 设置 rpld 的color pixelFormat，一般是 .bgra8Unorm
- 根据 rpld 创建 rps MTLRenderPipelineState


```
func registerShaders() {
    let library = device!.newDefaultLibrary()!
    let vertex_func = library.newFunctionWithName("vertex_func")
    let frag_func = library.newFunctionWithName("fragment_func")
    let rpld = MTLRenderPipelineDescriptor()
    rpld.vertexFunction = vertex_func
    rpld.fragmentFunction = frag_func
    rpld.colorAttachments[0].pixelFormat = .BGRA8Unorm
    do {
        try rps = device!.newRenderPipelineStateWithDescriptor(rpld)
    } catch let error {
        self.print("\(error)")
    }
}
```


### 画

在draw function中，我们并不需要做任何改变：

1. 创建 drawable currentDrawable
2. 创建 rpd currentRenderPassDescriptor
3. 设置rpd 的 clearColor
4. 创建 commandBuffer
5. 创建 commandEncoder
6. 设置 commandEncoder 的renderPipelineState
7. 设置 commandEncoder 的VertexBuffer
8. 画 commandEncoder.drawPrimitives
9. commandEncoder endEncoding
10. commandBuffer present drawable
11. commandBuffer commit 真正的推送到画布上（？


```
    override func draw(_ dirtyRect: NSRect) {
        if let drawable = currentDrawable, let rpd = currentRenderPassDescriptor {
            rpd.colorAttachments[0].clearColor = MTLClearColorMake(0.5, 0.5, 0.5, 1.0)
            let commandBuffer = commandQueue!.makeCommandBuffer()
            let commandEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: rpd)
            commandEncoder.setRenderPipelineState(rps!)
            commandEncoder.setVertexBuffer(vertexBuffer, offset: 0, at: 0)
            commandEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3, instanceCount: 1)
            commandEncoder.endEncoding()
            commandBuffer.present(drawable)
            commandBuffer.commit()
        }
    }
```

### Shader

`vertex Vertex vertex_func` ，第一个vertex是qualifier, 只有三种： vertex, fragment, kernel. 第二个是return type，是我们定义的 Vertex struct这个类型，然后就是 functiona name了，也是我们之前对应的`  let vertex_func = library.newFunctionWithName("vertex_func")`这里面的，

constant 应该是pointer的类型，然后这里的 buffer(0) 是对应 `commandEncoder.setVertexBuffer(vertexBuffer, offset: 0, at: 0)`，的 at 0？ 也就像我们的OpenGL layout = 0 一样？


至于 [[]]:

> The [[ … ]] syntax is used to declare attributes such as resource locations, shader inputs, and built-in variables that are passed back and forth between shaders and CPU.

至于第二个参数 uint vid [[vertex_id]]

>  In our case [[ vertex_id ]] is the per-vertex identifier used in communication. Metal generates the per-fragment inputs to a fragment function using the output from a vertex function and the fragments generated by the rasterizer. The per-fragment inputs are identified with the [[ stage_in ]] attribute qualifier.

按照我的理解，他就是一个必须参数（如果我们希望从vertex shader 传入 fragment shader中一些东西），是我们的 OpenGL 中 shader中 in/out 来传递东西的，所以我们传递了这个vertices[vid]，然后在fragment shader中，我们直接来取这个vert，因为它也是一个Vertex Struct的颜色这个component，然后return 颜色就完成。

当然因为都是float4，所以我们也可以return position，变成有一些略为变化的全黄了？


```
#include <metal_stdlib>
using namespace metal;

struct Vertex {
    float4 position [[position]];
    float4 color;
};

vertex Vertex vertex_func(constant Vertex *vertices [[buffer(0)]],
                          uint vid [[vertex_id]]) {
    return vertices[vid];
}

fragment float4 fragment_func(Vertex vert [[stage_in]]) {
    return vert.color;
}

```

