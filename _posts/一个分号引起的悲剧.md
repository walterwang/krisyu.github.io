#一个分号引起的悲剧

###Compare And Swap

看伪码，大呼，看不懂，这个是如何做到lock别的processes/threads的？


```
int compAndSwap(int *word, int empty_val, int occup_val) {  int val = *word;  if(val == empty_val) *word = occup_val;  return val;}

```

这里我还是明白的，特别的一点就是每次return 的是旧的val， 比较val 和empty_val，如果相同就把*word更为新的occup_val, 这也是叫compare and swap的原因吧。


然后就到了发狂的阶段了

```
/* program mutualexclusion */

const int n = / * number of processes */
int bolt;
void P(int i)
{
	while(true){
		while ( compare_and_swap(bolt, 0, 1) == 1);
		/ * critical section * /;
		bolt = 0 ;
		/ * remainder * /;
		
	}
}

void main() 
{
	bolt = 0;
	parbegin ( P(1), P(2), ... , P(n) );

}

```

悲剧的点就在于我少看了一份分号，最重要的点处的分号，然后现在让我再度分析：

- bolt = 0， 对于 P(1)

```
 	val  = 0;
  	bolt = 1;
  	return 0;
	while 这一句不满足，所以进入 critical section 阶段
```


- P(1)  在 critical section 阶段，考察 P(2)....

```
	val = 1;
	bolt = 1;
	return 1;

	所以其他的process/threads 都被困在了while 循环里，这也是被叫做busy waiting的原因，其他的process也没让processor那么闲着啊
```

- P(1) 离开 critical section, 此时bolt被重置为0，下一个process/thread有机会进入，同样的也会让别的无法进入，这样就保证了mutal exclusion



优劣不再赘述


###Semaphore

