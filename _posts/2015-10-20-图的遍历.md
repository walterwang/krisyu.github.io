#图的遍历

之前笔记系列之二

###DFS（Depth First Search）

```
void DFS( Vertex V)
{
	visited[V] = true;
	for ( V的每个邻接点W )
		if ( !visited[W])
			DFS(W);
}
```

原路返还

堆栈

N个顶点，E条边

邻接表 V的邻接点 → E 能找到, N个定点 O（N+E）

邻接矩阵 找邻接点 每行扫一次，一共N行 O（N^2)


###BFS (Breadth First Search)


```
void BFS(Vertex V)
{
	visited[V] = true;
	Enqueue(V,Q);
	while(!IsEmpty(Q)){
		V = Dequeue(Q);
		for (V的每个邻接点W)
			if (!visited[W]){
				visited[W] = true;
				Enqueue(W,Q);
			}
	}
}
```

时间复杂度和DFS一样

###图不连通
图不连通怎么办?


```
void ListComponents(Graph G)
{
    for (each V in G)
        if (!visited[V]) {
            DFS(V);
        }
}

```



todo : 

- implement a graph via adjecent matrix
- implement a graph via adjecent linked lists
 


###Wikipedia

wikipedia真心良心，DFS它写了一个有意思的伪码，看看：

```
procedure DFS-iterative(G,v):
	let S be a stack
    S.push(v)
    while S is not empty
          v = S.pop()
          if v is not labeled as discovered:
              label v as discovered
              for all edges from v to w in G.adjacentEdges(v) do
                  S.push(w)
```

因为recusrsion的原理也就是stack.