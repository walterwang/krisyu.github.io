#O(n^2)排序代表们

###Bubble Sort

原理： 两两比较，大的下移，小的上浮，like 冒泡
第一趟： N-1 → N排好
第二趟： N-2 → N-1排好
 ...
所以需要两重循环
一个用于控制第二个循环的终点
另加flag之后可以用于判断，如果走一圈完全没有交换则说明排序已经完成

```

void bubble_sort(int a[], int n){
	for(int p = n-1; p >= 0 ;p--){
		int flag = 0;
		for(int i = 0; i < n ;i++){ //一趟冒泡
			if(a[i] > a[i+1]){
				swap(a[i],a[i+1]);
				flag = 1; //标记发生了变化
			}
		}
		if(flag == 0) break;//无交换，已经排序完毕
	}
}

```

Best Case : O(N)，顺序
Worst Case : O(N^2) 逆序

###Insertion Sort

拿扑克
拿到的扑克与手上的比，如果比最后一张大，则直接放于此张之后
如果比最后一张小，那么就需要继续向前比，知道遇到比其小的，那么放于此张之后

```
void insertion_sort(int a[],int n)
{
    int p,tmp,i;
    for ( p = 1; p < n; p++){
        tmp = a[p];
        for (i = p; i > 0 && a[i-1] > tmp; i--)
            a[i] = a[i-1];
        a[i] = tmp;
    }
}
```
两重循环，同样Wrost Case O(N^2)

###Selection Sort


选择排序是这样一种排序
从a[i]到a[n]中找到最小，然后将其放在已经排好序部分的最后位置

首先如果a[]中就零个元素，那么其就是有序的，每次找到最小的，往后叠，就会逐渐有序


```
void selection_sort(int a[], int n){
	int i,j,smallIdx;
	
	for(i = 0 ; i < n-1; i++){
		smallIdx = i;
		for(j = i+1 ; j < n ;j++){
			if(a[j] < a[smallIdx]){
				smallIdx = j;
			}
		}
		if(smallIdx != i)
			swap(a[i],a[smallIdx]);
	}
}
```
两重循环，同样Wrost Case O(N^2)

如果在链表上做selection sort，只能交换data field...

