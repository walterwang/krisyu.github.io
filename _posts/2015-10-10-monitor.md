#Monitor 

### cwait and csignal

看教科书Producer/Consumer，一处疑惑，再读之，是因为monitor里面用的是conditional variable，也就是boolean值，cwait()是suspend/block，csignal()是resume execution.


```
void append(char x)
{
	if (count == N) cwait(notfull);    /* buffer is full; avoid overflow */
	...
}
```

所以此处的理解应当是，count == N， notfull为false了，这个时候就将调用append这个线程blocked掉，直到count < N ,notfull为true，才再度释放，执行下方的语句，是和compare and swap有类似的感觉嘛....


###Monitors in Java


- Object.wait() call the calling thread to wait(block) for notify() to be called on the same object.

- Object.notify() releases a thread that is blocked by a wait() on the same object

- Object.notifyAll() releases all threads blocked by a wait on the same object.

还是看一个🌰减少抽象， [File][id]

[id]:https://github.com/KrisYu/OSConceptsExamples/blob/master/CriticalSectionMonitor.java

写起来也没有这么简单，可以注意的点：

- 		// Needed to start / unblock the first waiting thread. 
		synchronized(monitor) {
			monitor.notify();
		}
		否则程序不会开始运行



-			
			synchronized(monitor) {  // Start Critical Section
				monitor.wait();
			}
			
			....//CS code
			
			synchronized(monitor) { // End Critical Section
				monitor.notify();
			}
			
-			Thread.yield();

thread 需要yield让位


另外，其实synchronize和monitor我表示迷茫...


###可以玩的点

改此处代码：
改成notifyAll

```
// Needed to start / unblock the first waiting thread. 
synchronized(monitor) {
	monitor.notifyAll();
}
```

结果会出错，因为notifyAll是release all threads，打印结果如下：

错的点是在于一开始就把所有的threads放了出来

```
...
 wsN AshoIsn
 
e
Moo loe
...

```


当然改代码把这里改成notifyAll()也会出类似的错误...


```
synchronized(monitor) { // End Critical Section
	monitor.notify();
}
```


