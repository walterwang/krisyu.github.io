#Heap君

###Defination



• Implementation of a priority queue
• An array, visualized as a nearly complete binary tree
• Max Heap Property: The key of a node is ≥ than the keys of its children(Min Heap defined analogously)

<br \>


所以这个Heap的定义也很递归

来一个MaxHeap如下：



```
 			 16
 		/          \
 	   14          10		
	 /     \      /   \
    8      7     9     3
   / \    /
  2   4  1
  
```

array 表示：

```

  0   1  | 2  |  3 |  4 |  5 |  6 | 7  | 8  |  9 | 10 |
+---+----+----+----+----+----+----+----+----+----+----+
| ? | 16 | 14 | 10 |  8 |  7 |  9 | 3  |  2 |  4 |  1 |
+---+----+----+----+----+----+----+----+----+----+----+

```


the 0 position can put the size of the array, or left blank, or a very large sentry.( 然后反应过来怎么在写英文...)



###可以注意的点


首先是不同于BST，这棵树的左右孩子是没有大小关系，只需要注意顶点，顶点是最特殊的。（最大/最小）
其次是这课树一定是一个complete binary tree.

再复习一下


full binary tree  : full binary tree的重点是 full binary，全是binary


```
 			 o
 		   /   \	
          o     o
         / \
        o   o
           / \
          o   o   
```


complete binary tree : complete binary tree的重点是缺孩子只能缺最后一排右边的


```
 			  o
 		   /    \	
          o      o
         / \    / \
        o   o  o   o
       /   / \
      o   o   o   
```


perfert binary tree (proper binary tree) : 

```
			  o
 		   /    \	
          o       o
         / \     / \
        o   o   o   o

```

###max_heapify 


max_heapify : correct a single violation of the heap property in a subtree at its root

所以max_heapify的前提是只有i处是违反了heap property的：



``` 		
  			 16
 		/          \
 	   |4|         10		
	 /     \      /   \
    14      7     9     3
   / \    /
  2   8  1
  

```

上个例子中，4出错。

那么需要做的是：

4 与其孩子比较， 14/7 选大的 14，交换位置

``` 		
  			 16
 		/          \
 	   14	       10		
	 /     \      /   \
   |4|      7     9     3
   / \    /
  2   8  1
  

```


交换位置之后依旧没有完全匹配heap property，继续：



``` 		
  			 16
 		/          \
 	   14	       10		
	 /     \      /   \
   |4|      7     9     3
   / \    /
  2   8  1
  

```

4 继续与其孩子比较， 2/8选大的 8，交换位置


``` 		
  			 16
 		/          \
 	   14	       10		
	 /     \      /   \
    8      7     9     3
   / \    /
  2   4  1
  

```

最终交换完毕，完美解决。

因为这种特性，所以


###Max_Heapify Pseudocode来一发

<br />

```

l = left(i)r = right(i)if (l <= heap-size(A) and A[l] > A[i])	then largest = l else largest = iif (r <= heap-size(A) and A[r] > A[largest])	then largest = r if largest ≠  i	then exchange A[i] and A[largest]		Max_Heapify(A, largest)

```



我一直在思考一个问题，那就是为嘛要用array来implement，既然有C++，为什么，为什么要嫌弃我们vector，这一切都是为什么，大家都是用C来写数据结构么？好吧，其实也不是，好吧，我看到了用vector来implement heap

还有因为此种特性，所以也叫 percDown / percUp




###Build_Max_Heap(A)

Converts A[1...n] to a max heap

```Build_Max_Heap(A): 	for i=n/2 downto 1		do Max_Heapify(A, i)

```

很容易考虑，因为从 n/2才有孩子，n/2之后的都是叶子结点。然后因为之前的heapify 是针对i之后的完备，仅有i被破坏，所以这样一圈下来就可以build一个健康的MaxHeap了.


###时间复杂度

粗看很容易觉得时间复杂度是 O(n log n)， 因为for的步骤 n/2, 然后每一个do 是最多交换lgn次。

但是实际上，随着层数的往上走，每一层的节点数在减少，交换的次数在增加，实际上

```
此处略去数学

```

时间复杂度是O(n)


###HeapSort
Sorting Strategy:1. Build Max Heap from unordered array; 2. Find maximum element A[1];3. Swap elements A[n] and A[1]:now max element is at the end of the array!4. Discard node n from heap(by decrementing heap-size variable)5. New root may violate max heap property, but its children are max heaps. Run max_heapify to fix this.6. Go to Step 2 unless heap is empty.

 
###To be Done:

你倒是把 heap 和 heap_sort写出来啊



