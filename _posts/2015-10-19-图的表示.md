#图的表示

之前笔记系列之一

###定义

包含“多对多”的关系  
包含

- 一组顶点  V(Vertex)  顶点集
- 一组边   E(Edge)  边的集合
 	
 	边是顶点对： （v , w）∈ V
 	
 	有向边 ： <v, w> ∈ V 单行线
 	
 	不考虑重边和自回路

连通
不连通

线性表和树可理解为图的特殊情况


###抽象数据类型定义

类型名称： 图（Graph）
数据对象集： G（V，E） 非空有限顶点集合V和一个有限边集合E组成
操作集： 图G ∈ Graph， v ∈ V

 - Graph Create() ：建立返回空图
 - Graph InsertVertex(Graph G, Vertex v)
 - Graph InsertEdge(Graph G, Edge e)
 - void DFS(Graph G, Vertex v) 深优先遍历图G
 - void BFS(Graph G, Vertex v) 宽度优先遍历图G
 - void ShortestPath(Graph G, Vertex v, int Dist[]) 计算图G中从顶点v到任意其他顶点的最短举例
 - void MST（Graph G）计算图G的最小生成树
 .....


有向图  无向图
权重 →  网络


###表示

#####邻接矩阵 G[N][N]
一,邻接矩阵 G[N][N] -- N个顶点从0到N-1编号

```

			1 若 <vi，vj>是G的边
G[i][j] = ⧼ 
			0  否则

```

举个🌰


```

				     ⎡ 0  1  1  0 ⎤
 	1 - 2              1   0  0  1 
 	|   |              1   0  0  1
 	3 - 4            ⎣ 0   1  1  0 ⎦
 	
 ```
 
 
 对于无向图，可以用数组，节省一半空间 →  因为矩阵是对称的

用一个长度为 N(N+1)/2 的1维数组A存储
｛G<sub>00</sub>， G<sub>10</sub>， G<sub>11</sub>，.....G<sub>n-1 0</sub>,... G<sub>n-1 n-1</sub>｝

G<sub>ij</sub>在A中对应下标是：

	(i*(i+1)/2 + j)

 	
邻接矩阵 —— 有什么好处?

- 直观、简单、好理解
- 方便检查任意一对顶点间是否存在边
- 方便找任一顶点的所有“邻接点”(有边直接相连的顶点)
- 方便计算任一顶点的“度”(从该点发出的边数为“出 度”,指向该点的边数为“入度”)
- 无向图:对应行(或列)非0元素的个数
- 有向图:对应行非0元素的个数是"出度",对应列非0元素的个数是"入度"
  
邻接矩阵 —— 有什么不好?
 浪费矩阵 - 稀疏图

####关联矩阵

二，关联矩阵

p个顶点，q个边， p×q阶矩阵G[p][q]


```

			1 若vi关联 ej
G[i][j] = ⧼ 
			0  否则

```

如果是有向图的话，可以用1和-1来表示出度和入度。

###邻接表

三，邻接表

邻接表:G[N]为指针数组,对应矩阵每行一个链表, 只存非0元素



我也需要脑组织的进化

一是可以建立一个逆邻接表，跟领接表类似
这样这个表就专门来算出度

还有就是用十字链表
